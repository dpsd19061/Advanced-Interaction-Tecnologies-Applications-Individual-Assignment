# Lesson: Advanced Interaction Technologies & Applications

### First and Last Name: Efstratios Koutoulakis
### University Registration Number: dpsd19061
### GitHub Personal Profile: [dpsd19061](https://github.com/dpsd19061)
### Advanced Interaction Tecnologies & Applications Github Personal Repository: [Repository](https://github.com/dpsd19061/Advanced-Interaction-Tecnologies-Applications-Individual-Assignment)

# Introduction

# Summary

# 1st Deliverable

### 1ο Μέρος Παραδοτέου

--> Tο πρώτο task ήταν αρκετά απλό, άνοιξα το 1ο παράδειγμα του 16ου κεφαλαίου. Βεβαια η άσκηση δεν είχε τελειώσει διότι καθώς έτρεχα τον κώδικα "έσκαγε" ένα error. Δεν αναγνώριζε την κάμερα μου παρόλο που ήταν built in στο laptop μου. Εψαξα το σφάλμα και από [εδω](https://discourse.processing.org/t/processing-cant-find-the-camera-video-libraries-dont-work/25128) βρήκα πώς να το λύσω.

### 2ο Μέρος Παραδοτέου

--> Στο δεύτερο task χρησιμοποίησα αρκετό κώδικα από το βιβλίο (παραδείγματα 16-4 & 16-5) και υλοποίησα το περισσότερο κομμάτι. Για την ταχύτητα αναπαραγωγής, χρησιμοποιώντας την εντολή speed διαιρόντας το πλάτος του παραθύρου με το διπλάσιο position του mouse καταφέρνω να κάνω την ταχύτητα να αυξάνεται στο δεξύ μέρος της οθόνης και αντίστοιχα μειώνεται στο αριστερό μέρος. Μια προσθήκη που έκανα, επειδή οταν το ποντίκι πηγαίνει πολύ αριστερά στην οθόνη, η ταχύτητα του βίντεο γίνεται υπερβολικά αργή, πρόσθεσα ενα if statement που λειτουργεί ως εξής: Οταν το ποντίκι βρίσκεται μεσα στα πρωτα 320 pixels η ταχύτητα παραμένει σταθερή στο 0.5. Ετσι η ταχύτητα μεταβάλλεται σε λογικά πλαίσια.

![ScreenShot](1.1.jpg)

### 3ο Μέρος Παραδοτέου

--> Το τρίτο task ήταν επίσης αρκετά εύκολο. Κατεβάζοντας την βιβλιοθήκη και από το site που μας δόθηκε και χρησιμοποιώντας τον κώδικα που παρείχε κατάφερα να κάνω decode την φωτογραφία με το QR. Από [εδώ](https://processing.org/examples/embeddedlinks.html) βρήκα τον τρόπο με τον οποίο ανοίγω το link που αποθηκεύεται στο εκάστοτε string. Για να εμφανίσω την φωτογραφία του QR, πολύ απλά έριξα μια μικρή ματιά στο κεφάλαιο 15 του βιβλίου.

### 4ο Μέρος Παραδοτέου

--> Στο τέταρτο task το μόνο που χρειάστηκε να κάνω ήταν να βάλω την εντολή που ανοίγει το URL μέσα στη μέθοδο που κάνει decode το QR και να φτιάξω έναν data φάκελο και να βάλω την φωτογραφία του QR. Οπότε όταν έχω το QR στην κάμερα και πατήσω το space το πρόγραμμα βγάζει ένα προσωρινό screenshot, το κάνει decode και ανοίγει το URL σε μια καρτέλα. Όταν όμως πατήσω το πλήκτρο f θα γίνει η ίδια διαδικασία απλά η φωτογραφία θα παρθεί από τον data φάκελο.

### 5ο Μέρος Παραδοτέου

--> Τέλος, ανοίγοντας το παράδειγμα από την βιβλιοθήκη για το AR και χρησιμοποιώντας κώδικα από το 2ο μέρος του παραδοτέου πρόσθεσα τον κώδικα που απαιτείται για φόρτωμα και αναπαραγωγή βίντεο και αντικατέστησα τις γραμμές κώδικα που σχημάτιζαν το box με τον κώδικα που εμφανίζει βίντεο. Βέβαια για να αποθηκεύσω το παράδειγμα ως ένα νέο sketch χρειάστηκε να μεταφέρω δύο αρχεία στο data φάκελο από τους φακέλους της βιβλιοθήκης και να αλλάξω κάποια paths μέσα στο processing.

# 2nd Deliverable

### 1ο Μέρος Παραδοτέου

--> Για το πρώτο task η διαδικασία υλοποίησής του έχει ως εξής: Σε πρώτη φάση, πρόσθεσα οτιδήποτε γραμμές κώδικα του παραδείγματος 16-11 που βοηθούν στο να φορτώσουν και να παίξουν το βίντεο στο background. Σε δεύτερη φάση, όπως αποθηκεύεται το χρώμα για κάθε pixel του βίντεο της κάμερας έτσι πρόσθεσα την ίδια εντολή γα να αποθηκεύεται το χρώμα για κάθε pixel του έτοιμου βίνεο. Τελος, το πρόγραμμα συγκρίνει τα pixels του background με τα ανανεωμένα pixels της κάμερας και ξέρει ακριβώς ποια pixel να αντικαταστήσει με το βίντεο και ποια να τα αφήσει (τα διαφορετικά pixels της κάμερας) ως έχου ανάλαγα με το threshold.

![Alt Text](s2.1.gif)

### 2ο Μέρος Παραδοτέου

--> Στο δεύτερο task άλλαξα το παράδειγμα 16_13 ως εξής: Πρόσθσα βίντεο από την κάμερα, ετσι ώστε να μην φαίνεται το ασπρόμαυρο και έγραψα τέτοιο κώδικα έτσι ώστε να υπολογίζει τον μέσο όρο των κάθε pixels που έχουν ανανεωθεί πρόσφατα (δηλαδή τοποθετεί τη σφαιρα στο μέσο όρο του εμβαδού των pixels).

![Alt Text](s2.2.gif)

### 3ο Μέρος Παραδοτέου

--> Το τρίτο task ήταν αρκετά απλό. Αντικατέστησα τις γραμμές κώδικα που ανοίγουν την κάμερα με τις γραμμές κώδικα που φορτώνουν καταγεγραμμένο βίντεο. Αλλαξα επίσης το χρώμα απο κόκινο σε μώβ και έβαλα ένα ημιδιαφανές fill.

--> **Απάντηση Ερώτησης:** Τα πλεονεκτήματα της έτοιμης βιβλιοθήκης είναι οτι μπορύμε να χρησιμοποιούμε έτοιμο κώδικα, χωρίς να γράφουμε δικό μας απο την αρχή, πράγμα που γλιτώνει υπερβολικά πολύ χρόνο. Με λίγα λόγια, δεν χρειάζεται να "εφευρίσκουμε τον τροχό από την αρχή". Επιπλέον ένα ακόμα πλεονέκτημα είναι οτι μια βιβλιοθήκη μπορεί να λειτουργεί και να ανταποδίδει καλύτερα αποτελέσματα απο έναν απλό developer γιατί η βιβλιοθήκη έχει κατασκευαστεί από ομάδα επαγγελματιών. Τα μειονεκτήματα της έτοιμης βιβλοθήκης είναι οτι αν έχουμε σκοπό να φτιάξουμε ένα πρόγραμμα με πολύ συγκεκριμένα ζητούμενα, η βιβλιοθήκη ενδεχομένως να μήν μας παρέχει πάντα αυτό που θέλουμε και δεν είναι εύκολο να τροποποιήσουμε τη βιβλιοθήκη με αποτέλεσμα να γράφουμε από την αρχή δικό μας κώδικα έστι ακριβώς όπως τον θέλουμε.

![Alt Text](s2.3.gif)

### 4ο Μέρος Παραδοτέου

--> Τέλος το τέταρτο task ήταν επίσης εύκολο. Αντικατέστησα το κομμάτι κώδικα που φτιάχνει τη σφαίρα με τον κωδικα που δημιουργεί το φίδι. Σημαντική λεπτομέρεια είναι οτι στον κώδικα του φιδιού, αντί για να ακολουθεί το x και y του ποντικού, τον άλλαξα έτσι ώστε να ακολουθεί το χρώμα που έχει επιλεχθεί. Επιπλέον έπαιξα και με τα χρώματα του φιδιού για αισθητικούς σκοπούς.

--> **Απάντηση Ερώτησης:** Τα πλεονεκτήματα χειρισμου του φιδιού με color tracking είναι οτι είναι πιο άμεσο και πιο διαδραστικό για τον χρήστη, επικοινωνεί άμεσα με το πρόγραμμα κινώντας αντικείμενα ή μόνο με το σώμα του. Τα μειονεκτήματα αυτού είναι οτι λόγω φωτισμού και ποιότητας κάμερας τα χρώματα αλλάζουν συνεχώς και αποτεσματικά το φίδι ενδέχεται να "τρεμοπαίζει" ή να μερδέυεται με παρόμοια χρώματα στην οθόνη και να μετακινείται σε ανεπιθύμιτες τοποθεσίες.

![Alt Text](s2.4.gif)

# 3rd Deliverable 

### Image Processing Application

--> Το πρώτο βήμα που έκανα για αυτό το παραδοτέο ήταν να σβήσω από το παράδειγμα TuioDemo ό,τι κώδικα δεν θα χρησιμοποιήσω. Στη συνέχεια φόρτωσα μια εικόνα και τοποθέτησα τον κώδικα με τέτοιο τρόπο έτσι ώστε όταν εμφανίζεται το fiducial 0 να εμφανίζεται και η εικόνα ακολουθώντας την θέση του και την περιστροφή του. Με τον ίδιο τρόπο πρόσθεσα 4 ακόμα fiducials τα οποία αλλάζουν το scale της εικόνας, το tint του χρώματος κόκκινου, το tintτου χρώματος πράσινου και το tint του χρώματος μπλέ. Ειναι επίσης σημαντικό να αναφέρω οτι λεγραψα τον κώδικα με τέτοιο τρόπο ετσι ωστε τα fiducials 1-4 να λειτουργούν μόνο όταν το fiducial 0 βρίσκεται μέσα.

--> **Απάντηση Ερώτησης:** Κατα την ανάπτυξη του λογισμικού διάδρασης, σε πρώτη φάση θα χρησιμοποιύσα τον προσωμοιωτή κυρίως για να δώ αν ο κώδικας λειτουργεί σωστά και μετά θα προχωρούσα στην κατασκευή μιας επιφάνειας πολυαφής με κάμερας. Αν το έκανα αντίστροφα (δηλ. υλοποίηση λογισμικού και χρήση κάμερας με επιφάνεια πολυαφής)
η υλοποίηση θα ήταν πολύ πιο σύνθετη και περίπλοκη.

![ScreenShot](3.1.jpg)

### Ερώτημα Bonus – Κατασκευή Απλής Επιφάνειας Πολυαφής

--> Για αυτό το ερώτημα κατασκεύασα ένα τραπεζάκι από χαρτόνι, στην επειφάνεια τοποθέτησα ένα τζάμι από κορνίζα και εκτύπωσα τα πρώτα πέντε fiducials (0-4). Δεν χρειάστηκε να αλλάξω κάτι στον κώδικα. Απο εκεί και πέρα το μόνο που χρειάστηκε να κάνω είναι να τρέξω παράλληλα το προγραμματάκι reacTIVision αντί για το simulator. Για να βρώ το προγραμματάκι reacTIVision με βοήθησε πολύ αυτό εδω το [βίντεο](https://www.youtube.com/watch?v=qKXlI4zAMAY&ab_channel=SergioL%C3%B3pezRey) αλλά και γενικότερα να καταλάβω πως λειτουργούν τα πράγματα.

### **--> Σε αυτό το [βίντεο](https://www.youtube.com/watch?v=MpdMEbIGoEY&ab_channel=%CE%A3%CF%84%CF%81%CE%AC%CF%84%CE%BF%CF%82%CE%9A%CE%BF%CF%85%CF%84%CE%BF%CF%85%CE%BB%CE%AC%CE%BA%CE%B7%CF%82) φαίνεται η υλοποίηση του παραδοτέου μου.**

# Bonus 

## Σε συνεργασία με: [Evedes01](https://github.com/Evedes01) (dpsd19030 Evangelia Despotidou)

### 0. Kinect Installation

--> Για την εγκατάσταση της κάμερας, ακολουθήσαμε πιστά τις οδηγίες από [εδώ](https://fivedots.coe.psu.ac.th/~ad/kinect/installation.html) και συνοδευτικά από τη [σελίδα](https://github.com/merkourisa/Advanced-Interaction-Tecnologies-Applications-Individual-Assignment/issues/4) στο GitHub. Επιπλέον δοκιμάσαμε κάποια έτοιμα παραδείγματα για να σιγουρευτούμε ότι εγκαταστήθηκε σωστά η κάμερα.

![ScreenShot](se4.1.jpg)
![ScreenShot](se4.2.jpg)
![ScreenShot](se4.3.jpg)

### 1. Nearest Point Tracking

--> Αρχικά, ανοίξαμε ένα νέο αρχείο processing, μέσα στο οποίο αντιγράψαμε τον κώδικα από το Project 5 του βιβλίου Making Things See. Έπειτα, ανοίξαμε το Παράδειγμα 9-8 (Learning Processing) και πήραμε τα κομμάτια κώδικα που δημιουργούν το φιδάκι.
<br><br>--> Στη συνέχεια, αντικαταστήσαμε τον κώδικα για τον κύκλο που ακολουθούσε την κίνηση του κοντινότερου σημείου με τον κώδικα για το φιδάκι. Τέλος, παίξαμε με τις τιμές και τις μεταβάσεις των χρωμάτων του φιδιού, ώστε να πηγαίνει από μπλε σε κόκκινο.

![Alt Text](se4.4.gif)

### 2. Background Removal

--> Για το δεύτερο πρόγραμμα, πήραμε το παράδειγμα Remove_Background_RGB και αντικαταστήσαμε το μαύρο background με ένα βίντεο της επιλογής μας, με τον ίδιο τρόπο που υλοποιήθηκε στο 1ο βήμα του 2ου παραδοτέου.
<br><br>--> Ουσιαστικά, ο κώδικας αποθηκεύει αρχικά τα pixel του βίντεο και της κάμερας. Από τα pixels τις κάμερας εμφανίζονται αυτά που αντιστοιχούν στον χρήστη και όλα τα υπόλοιπα αντικαθίστανται με τα pixels του βίντεο.

--> **Απάντηση Ερώτησης:** Τα πλεονεκτήματα της έτοιμης βιβλιοθήκης είναι οτι μπορύμε να χρησιμοποιούμε έτοιμο κώδικα, χωρίς να γράφουμε δικό μας απο την αρχή, πράγμα που γλιτώνει υπερβολικά πολύ χρόνο. Με λίγα λόγια, δεν χρειάζεται να "εφευρίσκουμε τον τροχό από την αρχή". Επιπλέον ένα ακόμα πλεονέκτημα είναι οτι μια βιβλιοθήκη μπορεί να λειτουργεί και να ανταποδίδει καλύτερα αποτελέσματα απο έναν απλό developer γιατί η βιβλιοθήκη έχει κατασκευαστεί από ομάδα επαγγελματιών. Τα μειονεκτήματα της έτοιμης βιβλοθήκης είναι οτι αν έχουμε σκοπό να φτιάξουμε ένα πρόγραμμα με πολύ συγκεκριμένα ζητούμενα, η βιβλιοθήκη ενδεχομένως να μήν μας παρέχει πάντα αυτό που θέλουμε και δεν είναι εύκολο να τροποποιήσουμε τη βιβλιοθήκη με αποτέλεσμα να γράφουμε από την αρχή δικό μας κώδικα έστι ακριβώς όπως τον θέλουμε. **Η kinect μπορεί να αναγνωρίζει πολύ εύκολα τα σωματα των ανθρώπων λόγω της τεχνολογίας της και μπορεί να κάνει πολύ πιο αποτελεσματικά το backround removal**.

![Alt Text](se4.5.gif)

### 3. Right-Hand Tracking

--> Τέλος, για το 3ο βήμα πήραμε τον κώδικα από το [άρθρο](http://articlesbyaphysicist.com/simpleopenni_windows_2.html) και τον βάλαμε σε καινούριο αρχείο. Στη συνέχεια, αντικαταστήσαμε τον κώδικα του κύκλου που ακολουθεί το αριστερό χέρι με τον κώδικα του φιδιού. Για τελικές πινελιές, παίξαμε με τις τιμές και τις μεταβάσεις των χρωμάτων του φιδιού, ώστε να πηγαίνει από κίτρινο σε κόκκινο και αλλάξαμε τον κώδικα ώστε η κάμερα να κάνει track το δεξί χέρι αντί το αριστερό.

![Alt Text](se4.6.gif)

# Bonus 2

## Σε συνεργασία με: [Evedes01](https://github.com/Evedes01) (dpsd19030 Evangelia Despotidou)

### Music Application

--> Αρχικά, ανοίξαμε το παράδειγμα “chPC_ex10_multi_hotpoint” από το βιβλίο Making Things See και προσπαθήσαμε να καταλάβουμε τι κάνει ο κώδικας. 
<br><br>--> Συνειδητοποιήσαμε ότι το πρόγραμμα δεν έδειχνε εικόνα από την κάμερα, αλλά γραφικά απεικόνισης βάθους, οπότε προσθέσαμε τον κατάλληλο κώδικα, ώστε να φαίνεται το βίντεο από την κάμερα. 
<br><br>--> Επεξεργαστήκαμε την τοποθεσία της κάμερας στο εικονικό περιβάλλον, ώστε το τρισδιάστατο περιβάλλον να συμπίπτει με το feed από την Kinect. Επειδή, το field of view της Kinect δεν ταίριαζε με το field of view της εικονικής κάμερας, βρήκαμε [κώδικα](https://processing.org/reference/perspective_.html), που κάνει αυτά τα δύο f.o.v. να ταυτίζονται. 
<br><br>--> Στη συνέχεια, ψάξαμε και βρήκαμε ηχητικά αποκόμματα και νότες από μουσικά όργανα που θέλαμε να συμπεριλάβουμε. Μετά προσθέσαμε όσους κύβους χρειαζόμασταν και τους στοιχίσαμε στον εικονικό χώρο αλλάζοντας τις μεταβλητές τοποθεσίας και μεγέθους.
<br><br>--> Έπειτα, εισαγάγαμε τα ηχητικά κομμάτια και τις μεταβλητές τους, τα οποία, στη συνέχεια, κάναμε assign στους ανάλογους κύβους.
<br><br>--> Τέλος, μετατρέψαμε τους κύβους σε σφαίρες, αντικαθιστώντας στον κώδικα το “box” με “sphere”.

### **--> Σε αυτό το [βίντεο](https://www.youtube.com/watch?v=IaqdazY2b4o&ab_channel=%CE%A3%CF%84%CF%81%CE%AC%CF%84%CE%BF%CF%82%CE%9A%CE%BF%CF%85%CF%84%CE%BF%CF%85%CE%BB%CE%AC%CE%BA%CE%B7%CF%82) φαίνεται η υλοποίηση του παραδοτέου.**

# Conclusions

# Sources
